<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# language QuasiQuotes #-}
<span class="lineno">    2 </span>{-# language TemplateHaskell #-}
<span class="lineno">    3 </span>
<span class="lineno">    4 </span>{- |
<span class="lineno">    5 </span>
<span class="lineno">    6 </span>The functions in this section perform various geometrical transformations of 2D
<span class="lineno">    7 </span>images. They do not change the image content but deform the pixel grid and map
<span class="lineno">    8 </span>this deformed grid to the destination image. In fact, to avoid sampling
<span class="lineno">    9 </span>artifacts, the mapping is done in the reverse order, from destination to the
<span class="lineno">   10 </span>source. That is, for each pixel @(x,y)@ of the destination image, the functions
<span class="lineno">   11 </span>compute coordinates of the corresponding &quot;donor&quot; pixel in the source image and
<span class="lineno">   12 </span>copy the pixel value:
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>@dst(x,y) = src(fx(x,y), fy(x,y))@
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>In case when you specify the forward mapping @\&lt;gx,gy&gt; : src -&gt; dst@, the OpenCV
<span class="lineno">   17 </span>functions first compute the corresponding inverse mapping @\&lt;fx,fy&gt;:dst-&gt;src@
<span class="lineno">   18 </span>and then use the above formula.
<span class="lineno">   19 </span>
<span class="lineno">   20 </span>The actual implementations of the geometrical transformations, from the most
<span class="lineno">   21 </span>generic remap and to the simplest and the fastest resize, need to solve two main
<span class="lineno">   22 </span>problems with the above formula:
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>* Extrapolation of non-existing pixels.
<span class="lineno">   25 </span>Similarly to the filtering functions described in the previous section, for some
<span class="lineno">   26 </span>@(x,y)@, either one of @fx(x,y)@, or @fy(x,y)@, or both of them may fall outside
<span class="lineno">   27 </span>of the image. In this case, an extrapolation method needs to be used. OpenCV
<span class="lineno">   28 </span>provides the same selection of extrapolation methods as in the filtering
<span class="lineno">   29 </span>functions. In addition, it provides the method 'BorderTransparent'. This means
<span class="lineno">   30 </span>that the corresponding pixels in the destination image will not be modified at
<span class="lineno">   31 </span>all.
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>* Interpolation of pixel values.
<span class="lineno">   34 </span>Usually @fx(x,y)@ and @fy(x,y)@ are floating-point numbers. This means that
<span class="lineno">   35 </span>@\&lt;fx,fy&gt;@ can be either an affine or perspective transformation, or radial lens
<span class="lineno">   36 </span>distortion correction, and so on. So, a pixel value at fractional coordinates
<span class="lineno">   37 </span>needs to be retrieved. In the simplest case, the coordinates can be just rounded
<span class="lineno">   38 </span>to the nearest integer coordinates and the corresponding pixel can be used. This
<span class="lineno">   39 </span>is called a nearest-neighbor interpolation. However, a better result can be
<span class="lineno">   40 </span>achieved by using more sophisticated interpolation methods , where a polynomial
<span class="lineno">   41 </span>function is fit into some neighborhood of the computed pixel
<span class="lineno">   42 </span>@(fx(x,y),fy(x,y))@, and then the value of the polynomial at @(fx(x,y),fy(x,y))@
<span class="lineno">   43 </span>is taken as the interpolated pixel value. In OpenCV, you can choose between
<span class="lineno">   44 </span>several interpolation methods. See resize for details.
<span class="lineno">   45 </span>-}
<span class="lineno">   46 </span>module OpenCV.ImgProc.GeometricImgTransform
<span class="lineno">   47 </span>    ( ResizeAbsRel(..)
<span class="lineno">   48 </span>    , resize
<span class="lineno">   49 </span>    , warpAffine
<span class="lineno">   50 </span>    , warpPerspective
<span class="lineno">   51 </span>    , invertAffineTransform
<span class="lineno">   52 </span>    , getPerspectiveTransform
<span class="lineno">   53 </span>    , getRotationMatrix2D
<span class="lineno">   54 </span>    , remap
<span class="lineno">   55 </span>    , undistort
<span class="lineno">   56 </span>    ) where
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>import &quot;base&quot; Data.Int ( Int32 )
<span class="lineno">   59 </span>import &quot;base&quot; Foreign.C.Types ( CFloat, CDouble )
<span class="lineno">   60 </span>import &quot;base&quot; System.IO.Unsafe ( unsafePerformIO )
<span class="lineno">   61 </span>import qualified Data.Vector as V
<span class="lineno">   62 </span>import qualified &quot;inline-c&quot; Language.C.Inline as C
<span class="lineno">   63 </span>import qualified &quot;inline-c&quot; Language.C.Inline.Unsafe as CU
<span class="lineno">   64 </span>import qualified &quot;inline-c-cpp&quot; Language.C.Inline.Cpp as C
<span class="lineno">   65 </span>import &quot;linear&quot; Linear.V2 ( V2(..) )
<span class="lineno">   66 </span>import &quot;linear&quot; Linear.Vector ( zero )
<span class="lineno">   67 </span>import &quot;this&quot; OpenCV.Core.Types
<span class="lineno">   68 </span>import &quot;this&quot; OpenCV.ImgProc.Types
<span class="lineno">   69 </span>import &quot;this&quot; OpenCV.Internal.C.Inline ( openCvCtx )
<span class="lineno">   70 </span>import &quot;this&quot; OpenCV.Internal.C.Types
<span class="lineno">   71 </span>import &quot;this&quot; OpenCV.Internal.Core.Types
<span class="lineno">   72 </span>import &quot;this&quot; OpenCV.Internal.Core.Types.Mat
<span class="lineno">   73 </span>import &quot;this&quot; OpenCV.Internal.Exception
<span class="lineno">   74 </span>import &quot;this&quot; OpenCV.Internal.ImgProc.Types
<span class="lineno">   75 </span>import &quot;this&quot; OpenCV.TypeLevel
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>--------------------------------------------------------------------------------
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>C.context openCvCtx
<span class="lineno">   80 </span>
<span class="lineno">   81 </span>C.include &quot;opencv2/core.hpp&quot;
<span class="lineno">   82 </span>C.include &quot;opencv2/imgproc.hpp&quot;
<span class="lineno">   83 </span>C.using &quot;namespace cv&quot;
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>#include &lt;bindings.dsl.h&gt;
<span class="lineno">   86 </span>#include &quot;opencv2/core.hpp&quot;
<span class="lineno">   87 </span>#include &quot;opencv2/imgproc.hpp&quot;
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>#include &quot;namespace.hpp&quot;
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>--------------------------------------------------------------------------------
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>data ResizeAbsRel
<span class="lineno">   94 </span>   = ResizeAbs Size2i -- ^ Resize to an absolute size.
<span class="lineno">   95 </span>   | ResizeRel (V2 Double)
<span class="lineno">   96 </span>     -- ^ Resize with relative factors for both the width and the height.
<span class="lineno">   97 </span>     deriving <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>marshalResizeAbsRel
<span class="lineno">  100 </span>    :: ResizeAbsRel
<span class="lineno">  101 </span>    -&gt; (Size2i, CDouble, CDouble)
<span class="lineno">  102 </span><span class="decl"><span class="istickedoff">marshalResizeAbsRel (ResizeAbs s) = (s, 0   , 0   )</span>
<span class="lineno">  103 </span><span class="spaces"></span><span class="istickedoff">marshalResizeAbsRel (ResizeRel f) = (s, c'fx, c'fy)</span>
<span class="lineno">  104 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  105 </span><span class="spaces">    </span><span class="istickedoff">s :: Size2i</span>
<span class="lineno">  106 </span><span class="spaces">    </span><span class="istickedoff">s = toSize (zero :: V2 Int32)</span>
<span class="lineno">  107 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  108 </span><span class="spaces">    </span><span class="istickedoff">(V2 c'fx c'fy) = realToFrac &lt;$&gt; f</span></span>
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>{- | Resizes an image
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>To shrink an image, it will generally look best with 'InterArea' interpolation,
<span class="lineno">  113 </span>whereas to enlarge an image, it will generally look best with 'InterCubic'
<span class="lineno">  114 </span>(slow) or 'InterLinear' (faster but still looks OK).
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>Example:
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>@
<span class="lineno">  119 </span>resizeInterAreaImg :: Mat ('S ['D, 'D]) ('S 3) ('S Word8)
<span class="lineno">  120 </span>resizeInterAreaImg = exceptError $
<span class="lineno">  121 </span>    withMatM (h ::: w + (w \`div` 2) ::: Z)
<span class="lineno">  122 </span>             (Proxy :: Proxy 3)
<span class="lineno">  123 </span>             (Proxy :: Proxy Word8)
<span class="lineno">  124 </span>             transparent $ \\imgM -&gt; do
<span class="lineno">  125 </span>      birds_resized &lt;-
<span class="lineno">  126 </span>        pureExcept $ resize (ResizeRel $ pure 0.5) InterArea birds_768x512
<span class="lineno">  127 </span>      matCopyToM imgM (V2 0 0) birds_768x512 Nothing
<span class="lineno">  128 </span>      matCopyToM imgM (V2 w 0) birds_resized Nothing
<span class="lineno">  129 </span>      lift $ arrowedLine imgM (V2 startX y) (V2 pointX y) red 4 LineType_8 0 0.15
<span class="lineno">  130 </span>  where
<span class="lineno">  131 </span>    [h, w] = miShape $ matInfo birds_768x512
<span class="lineno">  132 </span>    startX = round $ fromIntegral w * (0.95 :: Double)
<span class="lineno">  133 </span>    pointX = round $ fromIntegral w * (1.05 :: Double)
<span class="lineno">  134 </span>    y = h \`div` 4
<span class="lineno">  135 </span>@
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>&lt;&lt;doc/generated/examples/resizeInterAreaImg.png resizeInterAreaImg&gt;&gt;
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>&lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#resize OpenCV Sphinx doc&gt;
<span class="lineno">  140 </span>-}
<span class="lineno">  141 </span>resize
<span class="lineno">  142 </span>    :: ResizeAbsRel
<span class="lineno">  143 </span>    -&gt; InterpolationMethod
<span class="lineno">  144 </span>    -&gt; Mat ('S [height, width]) channels depth
<span class="lineno">  145 </span>    -&gt; CvExcept (Mat ('S ['D, 'D]) channels depth)
<span class="lineno">  146 </span><span class="decl"><span class="istickedoff">resize factor interpolationMethod src = unsafeWrapException $ do</span>
<span class="lineno">  147 </span><span class="spaces">    </span><span class="istickedoff">dst &lt;- newEmptyMat</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff">handleCvException (pure $ unsafeCoerceMat dst) $</span>
<span class="lineno">  149 </span><span class="spaces">      </span><span class="istickedoff">withPtr src   $ \srcPtr   -&gt;</span>
<span class="lineno">  150 </span><span class="spaces">      </span><span class="istickedoff">withPtr dst   $ \dstPtr   -&gt;</span>
<span class="lineno">  151 </span><span class="spaces">      </span><span class="istickedoff">withPtr dsize $ \dsizePtr -&gt;</span>
<span class="lineno">  152 </span><span class="spaces">        </span><span class="istickedoff">[cvExcept|</span>
<span class="lineno">  153 </span><span class="spaces">          </span><span class="istickedoff">cv::resize</span>
<span class="lineno">  154 </span><span class="spaces">          </span><span class="istickedoff">( *$(Mat * srcPtr)</span>
<span class="lineno">  155 </span><span class="spaces">          </span><span class="istickedoff">, *$(Mat * dstPtr)</span>
<span class="lineno">  156 </span><span class="spaces">          </span><span class="istickedoff">, *$(Size2i * dsizePtr)</span>
<span class="lineno">  157 </span><span class="spaces">          </span><span class="istickedoff">, $(double fx)</span>
<span class="lineno">  158 </span><span class="spaces">          </span><span class="istickedoff">, $(double fy)</span>
<span class="lineno">  159 </span><span class="spaces">          </span><span class="istickedoff">, $(int32_t c'interpolation)</span>
<span class="lineno">  160 </span><span class="spaces">          </span><span class="istickedoff">);</span>
<span class="lineno">  161 </span><span class="spaces">        </span><span class="istickedoff">|]</span>
<span class="lineno">  162 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  163 </span><span class="spaces">    </span><span class="istickedoff">(dsize, fx, fy) = marshalResizeAbsRel factor</span>
<span class="lineno">  164 </span><span class="spaces">    </span><span class="istickedoff">c'interpolation = marshalInterpolationMethod interpolationMethod</span></span>
<span class="lineno">  165 </span>
<span class="lineno">  166 </span><span class="decl"><span class="nottickedoff">#num WARP_FILL_OUTLIERS</span>
<span class="lineno">  167 </span><span class="spaces"></span><span class="nottickedoff"></span></span><span class="decl"><span class="istickedoff">#num WARP_INVERSE_MAP </span>
<span class="lineno">  168 </span><span class="spaces"></span><span class="istickedoff"></span></span>
<span class="lineno">  169 </span>{- | Applies an affine transformation to an image
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>Example:
<span class="lineno">  172 </span>
<span class="lineno">  173 </span>@
<span class="lineno">  174 </span>rotateBirds :: Mat (ShapeT [2, 3]) ('S 1) ('S Double)
<span class="lineno">  175 </span>rotateBirds = getRotationMatrix2D (V2 256 170 :: V2 CFloat) 45 0.75
<span class="lineno">  176 </span>
<span class="lineno">  177 </span>warpAffineImg :: Kodak_512x341
<span class="lineno">  178 </span>warpAffineImg = exceptError $
<span class="lineno">  179 </span>    warpAffine birds_512x341 rotateBirds InterArea False False (BorderConstant black)
<span class="lineno">  180 </span>
<span class="lineno">  181 </span>warpAffineInvImg :: Kodak_512x341
<span class="lineno">  182 </span>warpAffineInvImg = exceptError $
<span class="lineno">  183 </span>    warpAffine warpAffineImg rotateBirds InterCubic True False (BorderConstant black)
<span class="lineno">  184 </span>@
<span class="lineno">  185 </span>
<span class="lineno">  186 </span>&lt;&lt;doc/generated/birds_512x341.png             original        &gt;&gt;
<span class="lineno">  187 </span>&lt;&lt;doc/generated/examples/warpAffineImg.png    warpAffineImg   &gt;&gt;
<span class="lineno">  188 </span>&lt;&lt;doc/generated/examples/warpAffineInvImg.png warpAffineInvImg&gt;&gt;
<span class="lineno">  189 </span>
<span class="lineno">  190 </span>&lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#warpaffine OpenCV Sphinx doc&gt;
<span class="lineno">  191 </span>-}
<span class="lineno">  192 </span>warpAffine
<span class="lineno">  193 </span>    :: Mat ('S [height, width]) channels depth -- ^ Source image.
<span class="lineno">  194 </span>    -&gt; Mat (ShapeT [2, 3]) ('S 1) ('S Double) -- ^ Affine transformation matrix.
<span class="lineno">  195 </span>    -&gt; InterpolationMethod
<span class="lineno">  196 </span>    -&gt; Bool -- ^ Perform the inverse transformation.
<span class="lineno">  197 </span>    -&gt; Bool -- ^ Fill outliers.
<span class="lineno">  198 </span>    -&gt; BorderMode -- ^ Pixel extrapolation method.
<span class="lineno">  199 </span>    -&gt; CvExcept (Mat ('S [height, width]) channels depth) -- ^ Transformed source image.
<span class="lineno">  200 </span><span class="decl"><span class="istickedoff">warpAffine src transform interpolationMethod inverse fillOutliers borderMode =</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">unsafeWrapException $ do</span>
<span class="lineno">  202 </span><span class="spaces">      </span><span class="istickedoff">dst &lt;- newEmptyMat</span>
<span class="lineno">  203 </span><span class="spaces">      </span><span class="istickedoff">handleCvException (pure $ unsafeCoerceMat dst) $</span>
<span class="lineno">  204 </span><span class="spaces">        </span><span class="istickedoff">withPtr src $ \srcPtr -&gt;</span>
<span class="lineno">  205 </span><span class="spaces">        </span><span class="istickedoff">withPtr dst $ \dstPtr -&gt;</span>
<span class="lineno">  206 </span><span class="spaces">        </span><span class="istickedoff">withPtr transform   $ \transformPtr -&gt;</span>
<span class="lineno">  207 </span><span class="spaces">        </span><span class="istickedoff">withPtr    borderValue $ \borderValuePtr -&gt;</span>
<span class="lineno">  208 </span><span class="spaces">          </span><span class="istickedoff">[cvExcept|</span>
<span class="lineno">  209 </span><span class="spaces">            </span><span class="istickedoff">Mat * src = $(Mat * srcPtr);</span>
<span class="lineno">  210 </span><span class="spaces">            </span><span class="istickedoff">cv::warpAffine</span>
<span class="lineno">  211 </span><span class="spaces">              </span><span class="istickedoff">( *src</span>
<span class="lineno">  212 </span><span class="spaces">              </span><span class="istickedoff">, *$(Mat * dstPtr)</span>
<span class="lineno">  213 </span><span class="spaces">              </span><span class="istickedoff">, *$(Mat * transformPtr)</span>
<span class="lineno">  214 </span><span class="spaces">              </span><span class="istickedoff">, src-&gt;size()</span>
<span class="lineno">  215 </span><span class="spaces">              </span><span class="istickedoff">, $(int32_t c'interpolationMethod) | $(int32_t c'inverse) | $(int32_t c'fillOutliers)</span>
<span class="lineno">  216 </span><span class="spaces">              </span><span class="istickedoff">, $(int32_t c'borderMode)</span>
<span class="lineno">  217 </span><span class="spaces">              </span><span class="istickedoff">, *$(Scalar * borderValuePtr)</span>
<span class="lineno">  218 </span><span class="spaces">              </span><span class="istickedoff">);</span>
<span class="lineno">  219 </span><span class="spaces">          </span><span class="istickedoff">|]</span>
<span class="lineno">  220 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  221 </span><span class="spaces">    </span><span class="istickedoff">c'interpolationMethod = marshalInterpolationMethod interpolationMethod</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="istickedoff">c'inverse      = if inverse      then c'WARP_INVERSE_MAP   else 0</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="istickedoff">c'fillOutliers = if <span class="tickonlyfalse">fillOutliers</span> then <span class="nottickedoff">c'WARP_FILL_OUTLIERS</span> else 0</span>
<span class="lineno">  224 </span><span class="spaces">    </span><span class="istickedoff">(c'borderMode, borderValue) = marshalBorderMode borderMode</span></span>
<span class="lineno">  225 </span>
<span class="lineno">  226 </span>-- | Applies a perspective transformation to an image
<span class="lineno">  227 </span>--
<span class="lineno">  228 </span>-- &lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#warpperspective OpenCV Sphinx doc&gt;
<span class="lineno">  229 </span>warpPerspective
<span class="lineno">  230 </span>    :: Mat ('S [height, width]) channels depth -- ^ Source image.
<span class="lineno">  231 </span>    -&gt; Mat (ShapeT [3, 3]) ('S 1) ('S Double) -- ^ Perspective transformation matrix.
<span class="lineno">  232 </span>    -&gt; InterpolationMethod
<span class="lineno">  233 </span>    -&gt; Bool -- ^ Perform the inverse transformation.
<span class="lineno">  234 </span>    -&gt; Bool -- ^ Fill outliers.
<span class="lineno">  235 </span>    -&gt; BorderMode -- ^ Pixel extrapolation method.
<span class="lineno">  236 </span>    -&gt; CvExcept (Mat ('S [height, width]) channels depth) -- ^ Transformed source image.
<span class="lineno">  237 </span><span class="decl"><span class="nottickedoff">warpPerspective src transform interpolationMethod inverse fillOutliers borderMode =</span>
<span class="lineno">  238 </span><span class="spaces">    </span><span class="nottickedoff">unsafeWrapException $ do</span>
<span class="lineno">  239 </span><span class="spaces">      </span><span class="nottickedoff">dst &lt;- newEmptyMat</span>
<span class="lineno">  240 </span><span class="spaces">      </span><span class="nottickedoff">handleCvException (pure $ unsafeCoerceMat dst) $</span>
<span class="lineno">  241 </span><span class="spaces">        </span><span class="nottickedoff">withPtr src $ \srcPtr -&gt;</span>
<span class="lineno">  242 </span><span class="spaces">        </span><span class="nottickedoff">withPtr dst $ \dstPtr -&gt;</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="nottickedoff">withPtr transform   $ \transformPtr   -&gt;</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="nottickedoff">withPtr    borderValue $ \borderValuePtr -&gt;</span>
<span class="lineno">  245 </span><span class="spaces">          </span><span class="nottickedoff">[cvExcept|</span>
<span class="lineno">  246 </span><span class="spaces">            </span><span class="nottickedoff">Mat * src = $(Mat * srcPtr);</span>
<span class="lineno">  247 </span><span class="spaces">            </span><span class="nottickedoff">cv::warpPerspective</span>
<span class="lineno">  248 </span><span class="spaces">              </span><span class="nottickedoff">( *src</span>
<span class="lineno">  249 </span><span class="spaces">              </span><span class="nottickedoff">, *$(Mat * dstPtr)</span>
<span class="lineno">  250 </span><span class="spaces">              </span><span class="nottickedoff">, *$(Mat * transformPtr)</span>
<span class="lineno">  251 </span><span class="spaces">              </span><span class="nottickedoff">, src-&gt;size()</span>
<span class="lineno">  252 </span><span class="spaces">              </span><span class="nottickedoff">, $(int32_t c'interpolationMethod) | $(int32_t c'inverse) | $(int32_t c'fillOutliers)</span>
<span class="lineno">  253 </span><span class="spaces">              </span><span class="nottickedoff">, $(int32_t c'borderMode)</span>
<span class="lineno">  254 </span><span class="spaces">              </span><span class="nottickedoff">, *$(Scalar * borderValuePtr)</span>
<span class="lineno">  255 </span><span class="spaces">              </span><span class="nottickedoff">);</span>
<span class="lineno">  256 </span><span class="spaces">          </span><span class="nottickedoff">|]</span>
<span class="lineno">  257 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="nottickedoff">c'interpolationMethod = marshalInterpolationMethod interpolationMethod</span>
<span class="lineno">  259 </span><span class="spaces">    </span><span class="nottickedoff">c'inverse      = if inverse      then c'WARP_INVERSE_MAP   else 0</span>
<span class="lineno">  260 </span><span class="spaces">    </span><span class="nottickedoff">c'fillOutliers = if fillOutliers then c'WARP_FILL_OUTLIERS else 0</span>
<span class="lineno">  261 </span><span class="spaces">    </span><span class="nottickedoff">(c'borderMode, borderValue) = marshalBorderMode borderMode</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>-- | Inverts an affine transformation
<span class="lineno">  264 </span>--
<span class="lineno">  265 </span>-- &lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#invertaffinetransform OpenCV Sphinx doc&gt;
<span class="lineno">  266 </span>invertAffineTransform
<span class="lineno">  267 </span>    :: Mat (ShapeT [2, 3]) ('S 1) depth -- ^
<span class="lineno">  268 </span>    -&gt; CvExcept (Mat (ShapeT [2, 3]) ('S 1) depth)
<span class="lineno">  269 </span><span class="decl"><span class="nottickedoff">invertAffineTransform matIn = unsafeWrapException $ do</span>
<span class="lineno">  270 </span><span class="spaces">    </span><span class="nottickedoff">matOut &lt;- newEmptyMat</span>
<span class="lineno">  271 </span><span class="spaces">    </span><span class="nottickedoff">handleCvException (pure $ unsafeCoerceMat matOut) $</span>
<span class="lineno">  272 </span><span class="spaces">      </span><span class="nottickedoff">withPtr matIn  $ \matInPtr -&gt;</span>
<span class="lineno">  273 </span><span class="spaces">      </span><span class="nottickedoff">withPtr matOut $ \matOutPtr -&gt;</span>
<span class="lineno">  274 </span><span class="spaces">        </span><span class="nottickedoff">[cvExcept|</span>
<span class="lineno">  275 </span><span class="spaces">           </span><span class="nottickedoff">cv::invertAffineTransform(*$(Mat * matInPtr), *$(Mat * matOutPtr));</span>
<span class="lineno">  276 </span><span class="spaces">        </span><span class="nottickedoff">|]</span></span>
<span class="lineno">  277 </span>
<span class="lineno">  278 </span>{- | Calculates a perspective transformation matrix for 2D perspective transform
<span class="lineno">  279 </span>
<span class="lineno">  280 </span>&lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#getperspectivetransform OpenCV Sphinx doc&gt;
<span class="lineno">  281 </span>-}
<span class="lineno">  282 </span>getPerspectiveTransform
<span class="lineno">  283 </span>    :: (IsPoint2 point2 CFloat)
<span class="lineno">  284 </span>    =&gt; V.Vector (point2 CFloat) -- ^ Array of 4 floating-point Points representing 4 vertices in source image
<span class="lineno">  285 </span>    -&gt; V.Vector (point2 CFloat) -- ^ Array of 4 floating-point Points representing 4 vertices in destination image
<span class="lineno">  286 </span>    -&gt; Mat (ShapeT [3,3]) ('S 1) ('S Double) -- ^ The output perspective transformation, 3x3 floating-point-matrix.
<span class="lineno">  287 </span><span class="decl"><span class="nottickedoff">getPerspectiveTransform srcPts dstPts = unsafeCoerceMat $ unsafePerformIO $</span>
<span class="lineno">  288 </span><span class="spaces">    </span><span class="nottickedoff">withArrayPtr (V.map toPoint srcPts) $ \srcPtsPtr -&gt;</span>
<span class="lineno">  289 </span><span class="spaces">        </span><span class="nottickedoff">withArrayPtr (V.map toPoint dstPts) $ \dstPtsPtr -&gt;</span>
<span class="lineno">  290 </span><span class="spaces">        </span><span class="nottickedoff">fromPtr</span>
<span class="lineno">  291 </span><span class="spaces">        </span><span class="nottickedoff">[CU.block| Mat * {</span>
<span class="lineno">  292 </span><span class="spaces">            </span><span class="nottickedoff">return new cv::Mat</span>
<span class="lineno">  293 </span><span class="spaces">            </span><span class="nottickedoff">( cv::getPerspectiveTransform($(Point2f * srcPtsPtr), $(Point2f * dstPtsPtr))</span>
<span class="lineno">  294 </span><span class="spaces">            </span><span class="nottickedoff">);</span>
<span class="lineno">  295 </span><span class="spaces">        </span><span class="nottickedoff">}|]</span></span>
<span class="lineno">  296 </span>
<span class="lineno">  297 </span>{- | Calculates an affine matrix of 2D rotation
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>&lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#getrotationmatrix2d OpenCV Sphinx doc&gt;
<span class="lineno">  300 </span>-}
<span class="lineno">  301 </span>getRotationMatrix2D
<span class="lineno">  302 </span>    :: (IsPoint2 point2 CFloat)
<span class="lineno">  303 </span>    =&gt; point2 CFloat -- ^ Center of the rotation in the source image.
<span class="lineno">  304 </span>    -&gt; Double
<span class="lineno">  305 </span>       -- ^ Rotation angle in degrees. Positive values mean counter-clockwise
<span class="lineno">  306 </span>       -- rotation (the coordinate origin is assumed to be the top-left corner).
<span class="lineno">  307 </span>    -&gt; Double -- ^ Isotropic scale factor.
<span class="lineno">  308 </span>    -&gt; Mat (ShapeT [2, 3]) ('S 1) ('S Double) -- ^ The output affine transformation, 2x3 floating-point matrix.
<span class="lineno">  309 </span><span class="decl"><span class="istickedoff">getRotationMatrix2D center angle scale = unsafeCoerceMat $ unsafePerformIO $</span>
<span class="lineno">  310 </span><span class="spaces">    </span><span class="istickedoff">withPtr (toPoint center) $ \centerPtr -&gt;</span>
<span class="lineno">  311 </span><span class="spaces">      </span><span class="istickedoff">fromPtr</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">[CU.block| Mat * {</span>
<span class="lineno">  313 </span><span class="spaces">        </span><span class="istickedoff">return new cv::Mat</span>
<span class="lineno">  314 </span><span class="spaces">        </span><span class="istickedoff">( cv::getRotationMatrix2D</span>
<span class="lineno">  315 </span><span class="spaces">          </span><span class="istickedoff">( *$(Point2f * centerPtr)</span>
<span class="lineno">  316 </span><span class="spaces">          </span><span class="istickedoff">, $(double c'angle)</span>
<span class="lineno">  317 </span><span class="spaces">          </span><span class="istickedoff">, $(double c'scale)</span>
<span class="lineno">  318 </span><span class="spaces">          </span><span class="istickedoff">)</span>
<span class="lineno">  319 </span><span class="spaces">        </span><span class="istickedoff">);</span>
<span class="lineno">  320 </span><span class="spaces">      </span><span class="istickedoff">}|]</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  322 </span><span class="spaces">    </span><span class="istickedoff">c'angle = realToFrac angle</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff">c'scale = realToFrac scale</span></span>
<span class="lineno">  324 </span>
<span class="lineno">  325 </span>{- | Applies a generic geometrical transformation to an image.
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>The function remap transforms the source image using the specified map:
<span class="lineno">  328 </span>
<span class="lineno">  329 </span>@dst(x,y) = src(map(x,y))@
<span class="lineno">  330 </span>
<span class="lineno">  331 </span>Example:
<span class="lineno">  332 </span>
<span class="lineno">  333 </span>@
<span class="lineno">  334 </span>remapImg
<span class="lineno">  335 </span>  :: forall (width    :: Nat)
<span class="lineno">  336 </span>            (height   :: Nat)
<span class="lineno">  337 </span>            (channels :: Nat)
<span class="lineno">  338 </span>            (depth    :: *  )
<span class="lineno">  339 </span>   . (Mat ('S ['S height, 'S width]) ('S channels) ('S depth) ~ Kodak_512x341)
<span class="lineno">  340 </span>  =&gt; Mat ('S ['S height, 'S width]) ('S channels) ('S depth)
<span class="lineno">  341 </span>remapImg = exceptError $ remap birds_512x341 transform InterLinear (BorderConstant black)
<span class="lineno">  342 </span>  where
<span class="lineno">  343 </span>    transform = exceptError $
<span class="lineno">  344 </span>                matFromFunc (Proxy :: Proxy [height, width])
<span class="lineno">  345 </span>                            (Proxy :: Proxy 2)
<span class="lineno">  346 </span>                            (Proxy :: Proxy Float)
<span class="lineno">  347 </span>                            exampleFunc
<span class="lineno">  348 </span>
<span class="lineno">  349 </span>    exampleFunc [_y,  x] 0 = wobble x w
<span class="lineno">  350 </span>    exampleFunc [ y, _x] 1 = wobble y h
<span class="lineno">  351 </span>    exampleFunc _pos _channel = error &quot;impossible&quot;
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>    wobble :: Int -&gt; Float -&gt; Float
<span class="lineno">  354 </span>    wobble v s = let v' = fromIntegral v
<span class="lineno">  355 </span>                     n = v' / s
<span class="lineno">  356 </span>                 in v' + (s * 0.05 * sin (n * 2 * pi * 5))
<span class="lineno">  357 </span>
<span class="lineno">  358 </span>    w = fromInteger $ natVal (Proxy :: Proxy width)
<span class="lineno">  359 </span>    h = fromInteger $ natVal (Proxy :: Proxy height)
<span class="lineno">  360 </span>@
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>&lt;&lt;doc/generated/birds_512x341.png original&gt;&gt;
<span class="lineno">  363 </span>&lt;&lt;doc/generated/examples/remapImg.png remapImg&gt;&gt;
<span class="lineno">  364 </span>
<span class="lineno">  365 </span>&lt;http://docs.opencv.org/3.0-last-rst/modules/imgproc/doc/geometric_transformations.html#remap OpenCV documentation&gt;
<span class="lineno">  366 </span>-}
<span class="lineno">  367 </span>remap
<span class="lineno">  368 </span>    :: Mat ('S [inputHeight, inputWidth]) inputChannels inputDepth
<span class="lineno">  369 </span>       -- ^ Source image.
<span class="lineno">  370 </span>    -&gt; Mat ('S [outputHeight, outputWidth]) ('S 2) ('S Float)
<span class="lineno">  371 </span>       -- ^ A map of @(x, y)@ points.
<span class="lineno">  372 </span>    -&gt; InterpolationMethod
<span class="lineno">  373 </span>       -- ^ Interpolation method to use. Note that 'InterArea' is not
<span class="lineno">  374 </span>       -- supported by this function.
<span class="lineno">  375 </span>    -&gt; BorderMode
<span class="lineno">  376 </span>    -&gt; CvExcept (Mat ('S [outputHeight, outputWidth]) inputChannels inputDepth)
<span class="lineno">  377 </span><span class="decl"><span class="istickedoff">remap src mapping interpolationMethod borderMode = unsafeWrapException $ do</span>
<span class="lineno">  378 </span><span class="spaces">    </span><span class="istickedoff">dst &lt;- newEmptyMat</span>
<span class="lineno">  379 </span><span class="spaces">    </span><span class="istickedoff">handleCvException (pure $ unsafeCoerceMat dst) $</span>
<span class="lineno">  380 </span><span class="spaces">      </span><span class="istickedoff">withPtr src $ \srcPtr -&gt;</span>
<span class="lineno">  381 </span><span class="spaces">      </span><span class="istickedoff">withPtr dst $ \dstPtr -&gt;</span>
<span class="lineno">  382 </span><span class="spaces">      </span><span class="istickedoff">withPtr mapping $ \mappingPtr -&gt;</span>
<span class="lineno">  383 </span><span class="spaces">      </span><span class="istickedoff">withPtr borderValue $ \borderValuePtr -&gt;</span>
<span class="lineno">  384 </span><span class="spaces">        </span><span class="istickedoff">[cvExcept|</span>
<span class="lineno">  385 </span><span class="spaces">          </span><span class="istickedoff">cv::remap</span>
<span class="lineno">  386 </span><span class="spaces">            </span><span class="istickedoff">( *$(Mat * srcPtr)</span>
<span class="lineno">  387 </span><span class="spaces">            </span><span class="istickedoff">, *$(Mat * dstPtr)</span>
<span class="lineno">  388 </span><span class="spaces">            </span><span class="istickedoff">, *$(Mat * mappingPtr)</span>
<span class="lineno">  389 </span><span class="spaces">            </span><span class="istickedoff">, {}</span>
<span class="lineno">  390 </span><span class="spaces">            </span><span class="istickedoff">, $(int32_t c'interpolation)</span>
<span class="lineno">  391 </span><span class="spaces">            </span><span class="istickedoff">, $(int32_t c'borderMode)</span>
<span class="lineno">  392 </span><span class="spaces">            </span><span class="istickedoff">, *$(Scalar * borderValuePtr)</span>
<span class="lineno">  393 </span><span class="spaces">            </span><span class="istickedoff">);</span>
<span class="lineno">  394 </span><span class="spaces">        </span><span class="istickedoff">|]</span>
<span class="lineno">  395 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  396 </span><span class="spaces">    </span><span class="istickedoff">c'interpolation = marshalInterpolationMethod interpolationMethod</span>
<span class="lineno">  397 </span><span class="spaces">    </span><span class="istickedoff">(c'borderMode, borderValue) = marshalBorderMode borderMode</span></span>
<span class="lineno">  398 </span>
<span class="lineno">  399 </span>
<span class="lineno">  400 </span>{-|
<span class="lineno">  401 </span>
<span class="lineno">  402 </span>The function transforms an image to compensate radial and tangential lens
<span class="lineno">  403 </span>distortion.
<span class="lineno">  404 </span>
<span class="lineno">  405 </span>Those pixels in the destination image, for which there is no correspondent
<span class="lineno">  406 </span>pixels in the source image, are filled with zeros (black color).
<span class="lineno">  407 </span>
<span class="lineno">  408 </span>The camera matrix and the distortion parameters can be determined using
<span class="lineno">  409 </span>@calibrateCamera@ . If the resolution of images is different from the resolution
<span class="lineno">  410 </span>used at the calibration stage, f_x, f_y, c_x and c_y need to be scaled accordingly,
<span class="lineno">  411 </span>while the distortion coefficients remain the same.
<span class="lineno">  412 </span>
<span class="lineno">  413 </span>Example:
<span class="lineno">  414 </span>
<span class="lineno">  415 </span>@
<span class="lineno">  416 </span>undistortImg
<span class="lineno">  417 </span>  :: forall (width    :: Nat)
<span class="lineno">  418 </span>            (height   :: Nat)
<span class="lineno">  419 </span>            (channels :: Nat)
<span class="lineno">  420 </span>            (depth    :: *  )
<span class="lineno">  421 </span>   . (Mat ('S ['S height, 'S width]) ('S channels) ('S depth) ~ Kodak_512x341)
<span class="lineno">  422 </span>  =&gt; Mat ('S ['S height, 'S width]) ('S channels) ('S depth)
<span class="lineno">  423 </span>undistortImg = undistort birds_512x341 intrinsics coefficients
<span class="lineno">  424 </span>  where intrinsics :: M33 Float
<span class="lineno">  425 </span>        intrinsics =
<span class="lineno">  426 </span>          V3 (V3 15840.8      0      2049)
<span class="lineno">  427 </span>             (V3     0    15830.3    1097)
<span class="lineno">  428 </span>             (V3     0        0         1)
<span class="lineno">  429 </span>
<span class="lineno">  430 </span>        coefficients :: Matx51d
<span class="lineno">  431 </span>        coefficients = unsafePerformIO $
<span class="lineno">  432 </span>          newMatx51d
<span class="lineno">  433 </span>            (-2.239145913492247)
<span class="lineno">  434 </span>             13.674526561736648
<span class="lineno">  435 </span>              3.650187848850095e-2
<span class="lineno">  436 </span>            (-2.0042015752853796e-2)
<span class="lineno">  437 </span>            (-0.44790921357620456)
<span class="lineno">  438 </span>@
<span class="lineno">  439 </span>
<span class="lineno">  440 </span>&lt;&lt;doc/generated/birds_512x341.png original&gt;&gt;
<span class="lineno">  441 </span>&lt;&lt;doc/generated/examples/undistortImg.png undistortImg&gt;&gt;
<span class="lineno">  442 </span>
<span class="lineno">  443 </span>-}
<span class="lineno">  444 </span>undistort
<span class="lineno">  445 </span>  :: ( ToMat m33d, MatShape m33d ~ 'S '[ 'S 3, 'S 3 ]
<span class="lineno">  446 </span>     , ToMat distCoeffs, MatShape distCoeffs `In` '[ 'S '[ 'S  4, 'S 1 ]
<span class="lineno">  447 </span>                                                   , 'S '[ 'S  5, 'S 1 ]
<span class="lineno">  448 </span>                                                   , 'S '[ 'S  8, 'S 1 ]
<span class="lineno">  449 </span>                                                   , 'S '[ 'S 12, 'S 1 ]
<span class="lineno">  450 </span>                                                   , 'S '[ 'S 14, 'S 1 ]
<span class="lineno">  451 </span>                                                   ]
<span class="lineno">  452 </span>     )
<span class="lineno">  453 </span>  =&gt; Mat ('S '[ h, w]) c d
<span class="lineno">  454 </span>    -- ^ The source image to undistort.
<span class="lineno">  455 </span>  -&gt; m33d
<span class="lineno">  456 </span>  -- ^ The 3x3 matrix of intrinsic parameters.
<span class="lineno">  457 </span>  -&gt; distCoeffs
<span class="lineno">  458 </span>  -- ^ The distortion coefficients
<span class="lineno">  459 </span>  --   (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τx,τy]]]]) of 4, 5, 8, 12 or 14 elements.
<span class="lineno">  460 </span>  -&gt; Mat ('S '[ h, w]) c d
<span class="lineno">  461 </span><span class="decl"><span class="istickedoff">undistort img camera distCoeffs = unsafePerformIO $ do</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="istickedoff">dst &lt;- newEmptyMat</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="istickedoff">withPtr img $ \imgPtr -&gt;</span>
<span class="lineno">  464 </span><span class="spaces">      </span><span class="istickedoff">withPtr dst $ \dstPtr -&gt;</span>
<span class="lineno">  465 </span><span class="spaces">      </span><span class="istickedoff">withPtr (toMat camera) $ \cameraPtr -&gt;</span>
<span class="lineno">  466 </span><span class="spaces">      </span><span class="istickedoff">withPtr (toMat distCoeffs) $ \distCoeffsPtr -&gt;</span>
<span class="lineno">  467 </span><span class="spaces">        </span><span class="istickedoff">[C.block| void {</span>
<span class="lineno">  468 </span><span class="spaces">          </span><span class="istickedoff">undistort(*$(Mat * imgPtr),</span>
<span class="lineno">  469 </span><span class="spaces">                    </span><span class="istickedoff">*$(Mat * dstPtr),</span>
<span class="lineno">  470 </span><span class="spaces">                    </span><span class="istickedoff">*$(Mat * cameraPtr),</span>
<span class="lineno">  471 </span><span class="spaces">                    </span><span class="istickedoff">*$(Mat * distCoeffsPtr));</span>
<span class="lineno">  472 </span><span class="spaces">        </span><span class="istickedoff">}|]</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">return (unsafeCoerceMat dst)</span></span>

</pre>
</body>
</html>
