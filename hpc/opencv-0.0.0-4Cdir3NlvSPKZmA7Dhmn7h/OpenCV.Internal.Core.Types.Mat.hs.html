<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="lineno">    1 </span>{-# language CPP #-}
<span class="lineno">    2 </span>{-# LANGUAGE RankNTypes #-}
<span class="lineno">    3 </span>{-# language QuasiQuotes #-}
<span class="lineno">    4 </span>{-# language ConstraintKinds #-}
<span class="lineno">    5 </span>{-# language TemplateHaskell #-}
<span class="lineno">    6 </span>{-# language UndecidableInstances #-}
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>#if __GLASGOW_HASKELL__ &gt;= 800
<span class="lineno">    9 </span>{-# options_ghc -Wno-redundant-constraints #-}
<span class="lineno">   10 </span>#endif
<span class="lineno">   11 </span>
<span class="lineno">   12 </span>{-# options_ghc -fno-warn-orphans #-}
<span class="lineno">   13 </span>
<span class="lineno">   14 </span>#ifndef ENABLE_INTERNAL_DOCUMENTATION
<span class="lineno">   15 </span>{-# OPTIONS_HADDOCK hide #-}
<span class="lineno">   16 </span>#endif
<span class="lineno">   17 </span>
<span class="lineno">   18 </span>module OpenCV.Internal.Core.Types.Mat
<span class="lineno">   19 </span>    ( -- * Matrix
<span class="lineno">   20 </span>      Mat(..)
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>    , typeCheckMat
<span class="lineno">   23 </span>    , relaxMat
<span class="lineno">   24 </span>    , coerceMat
<span class="lineno">   25 </span>    , unsafeCoerceMat
<span class="lineno">   26 </span>
<span class="lineno">   27 </span>    , keepMatAliveDuring
<span class="lineno">   28 </span>    , newEmptyMat
<span class="lineno">   29 </span>    , newMat
<span class="lineno">   30 </span>    , withMatData
<span class="lineno">   31 </span>    , matElemAddress
<span class="lineno">   32 </span>    , mkMat
<span class="lineno">   33 </span>    , cloneMat
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>      -- * Mutable matrix
<span class="lineno">   36 </span>    , typeCheckMatM
<span class="lineno">   37 </span>    , relaxMatM
<span class="lineno">   38 </span>    , coerceMatM
<span class="lineno">   39 </span>    , unsafeCoerceMatM
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>    , mkMatM
<span class="lineno">   42 </span>    , createMat
<span class="lineno">   43 </span>    , withMatM
<span class="lineno">   44 </span>    , cloneMatM
<span class="lineno">   45 </span>
<span class="lineno">   46 </span>      -- * Meta information
<span class="lineno">   47 </span>    , MatInfo(..)
<span class="lineno">   48 </span>    , matInfo
<span class="lineno">   49 </span>
<span class="lineno">   50 </span>    , dimPositions
<span class="lineno">   51 </span>
<span class="lineno">   52 </span>    , Depth(..)
<span class="lineno">   53 </span>    , marshalDepth
<span class="lineno">   54 </span>    , unmarshalDepth
<span class="lineno">   55 </span>    , marshalFlags
<span class="lineno">   56 </span>    , unmarshalFlags
<span class="lineno">   57 </span>
<span class="lineno">   58 </span>    , ShapeT
<span class="lineno">   59 </span>    , ChannelsT
<span class="lineno">   60 </span>    , DepthT
<span class="lineno">   61 </span>    , StaticDepthT
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>    , ToShape(toShape)
<span class="lineno">   64 </span>    , ToShapeDS(toShapeDS)
<span class="lineno">   65 </span>    , ToChannels, toChannels
<span class="lineno">   66 </span>    , ToChannelsDS, toChannelsDS
<span class="lineno">   67 </span>    , ToDepth(toDepth)
<span class="lineno">   68 </span>    , ToDepthDS(toDepthDS)
<span class="lineno">   69 </span>    ) where
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>import &quot;base&quot; Control.Monad.ST ( ST )
<span class="lineno">   72 </span>import &quot;base&quot; Data.Int
<span class="lineno">   73 </span>import &quot;base&quot; Data.Maybe
<span class="lineno">   74 </span>import &quot;base&quot; Data.Monoid ( (&lt;&gt;) )
<span class="lineno">   75 </span>import &quot;base&quot; Data.Proxy
<span class="lineno">   76 </span>import &quot;base&quot; Data.Word
<span class="lineno">   77 </span>import &quot;base&quot; Foreign.C.Types
<span class="lineno">   78 </span>import &quot;base&quot; Foreign.ForeignPtr ( ForeignPtr, withForeignPtr, touchForeignPtr )
<span class="lineno">   79 </span>import &quot;base&quot; Foreign.Marshal.Alloc ( alloca )
<span class="lineno">   80 </span>import &quot;base&quot; Foreign.Marshal.Array ( allocaArray, peekArray )
<span class="lineno">   81 </span>import &quot;base&quot; Foreign.Ptr ( Ptr, plusPtr )
<span class="lineno">   82 </span>import &quot;base&quot; Foreign.Storable ( Storable(..), peek )
<span class="lineno">   83 </span>import &quot;base&quot; GHC.TypeLits
<span class="lineno">   84 </span>import &quot;base&quot; System.IO.Unsafe ( unsafePerformIO )
<span class="lineno">   85 </span>import &quot;base&quot; Unsafe.Coerce ( unsafeCoerce )
<span class="lineno">   86 </span>import qualified &quot;inline-c&quot; Language.C.Inline as C
<span class="lineno">   87 </span>import qualified &quot;inline-c&quot; Language.C.Inline.Unsafe as CU
<span class="lineno">   88 </span>import qualified &quot;inline-c-cpp&quot; Language.C.Inline.Cpp as C
<span class="lineno">   89 </span>import &quot;primitive&quot; Control.Monad.Primitive ( PrimMonad, PrimState, unsafePrimToPrim )
<span class="lineno">   90 </span>import &quot;this&quot; OpenCV.Internal
<span class="lineno">   91 </span>import &quot;this&quot; OpenCV.Internal.C.Inline ( openCvCtx )
<span class="lineno">   92 </span>import &quot;this&quot; OpenCV.Internal.C.Types
<span class="lineno">   93 </span>import &quot;this&quot; OpenCV.Internal.C.PlacementNew.TH
<span class="lineno">   94 </span>import &quot;this&quot; OpenCV.Internal.Core.Types
<span class="lineno">   95 </span>import &quot;this&quot; OpenCV.Internal.Core.Types.Mat.Depth
<span class="lineno">   96 </span>import &quot;this&quot; OpenCV.Internal.Core.Types.Mat.Marshal
<span class="lineno">   97 </span>import &quot;this&quot; OpenCV.Internal.Exception
<span class="lineno">   98 </span>import &quot;this&quot; OpenCV.Internal.Mutable
<span class="lineno">   99 </span>import &quot;this&quot; OpenCV.TypeLevel
<span class="lineno">  100 </span>import &quot;transformers&quot; Control.Monad.Trans.Except
<span class="lineno">  101 </span>import qualified &quot;vector&quot; Data.Vector as V
<span class="lineno">  102 </span>import qualified &quot;vector&quot; Data.Vector.Generic as VG
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>--------------------------------------------------------------------------------
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>C.context openCvCtx
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>C.include &quot;opencv2/core.hpp&quot;
<span class="lineno">  109 </span>C.using &quot;namespace cv&quot;
<span class="lineno">  110 </span>
<span class="lineno">  111 </span>--------------------------------------------------------------------------------
<span class="lineno">  112 </span>-- Matrix
<span class="lineno">  113 </span>--------------------------------------------------------------------------------
<span class="lineno">  114 </span>
<span class="lineno">  115 </span>newtype Mat (shape    :: DS [DS Nat])
<span class="lineno">  116 </span>            (channels :: DS Nat)
<span class="lineno">  117 </span>            (depth    :: DS *)
<span class="lineno">  118 </span>      = Mat {<span class="istickedoff"><span class="decl"><span class="istickedoff">unMat</span></span></span> :: ForeignPtr (C (Mat shape channels depth))}
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>type instance C (Mat shape channels depth) = C'Mat
<span class="lineno">  121 </span>
<span class="lineno">  122 </span>type instance Mutable (Mat shape channels depth) = Mut (Mat shape channels depth)
<span class="lineno">  123 </span>
<span class="lineno">  124 </span>instance WithPtr (Mat shape channels depth) where
<span class="lineno">  125 </span>    <span class="decl"><span class="istickedoff">withPtr = withForeignPtr . unMat</span></span>
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>instance FromPtr (Mat shape channels depth) where
<span class="lineno">  128 </span>    <span class="decl"><span class="istickedoff">fromPtr = objFromPtr Mat $ \ptr -&gt;</span>
<span class="lineno">  129 </span><span class="spaces">                </span><span class="istickedoff">[CU.exp| void { delete $(Mat * ptr) }|]</span></span>
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>instance FreezeThaw (Mat shape channels depth) where
<span class="lineno">  132 </span>    <span class="decl"><span class="istickedoff">freeze = cloneMatM . unMut</span></span>
<span class="lineno">  133 </span>    <span class="decl"><span class="istickedoff">thaw = fmap Mut . cloneMatM</span></span>
<span class="lineno">  134 </span>
<span class="lineno">  135 </span>    <span class="decl"><span class="istickedoff">unsafeFreeze = pure . unMut</span></span>
<span class="lineno">  136 </span>    <span class="decl"><span class="istickedoff">unsafeThaw = pure . Mut</span></span>
<span class="lineno">  137 </span>
<span class="lineno">  138 </span>{- | Tests whether a 'Mat' is deserving of its type level attributes
<span class="lineno">  139 </span>
<span class="lineno">  140 </span>Checks if the properties encoded in the type of a 'Mat' correspond to
<span class="lineno">  141 </span>the value level representation. For each property that does not hold
<span class="lineno">  142 </span>this function will produce an error message. If everything checks out
<span class="lineno">  143 </span>it will produce an empty list.
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>The following properties are checked:
<span class="lineno">  146 </span>
<span class="lineno">  147 </span> * Dimensionality
<span class="lineno">  148 </span> * Size of each dimension
<span class="lineno">  149 </span> * Number of channels
<span class="lineno">  150 </span> * Depth (data type of elements)
<span class="lineno">  151 </span>
<span class="lineno">  152 </span>If a property is explicitly encoded as statically unknown ('D'ynamic)
<span class="lineno">  153 </span>it will not be checked.
<span class="lineno">  154 </span>-}
<span class="lineno">  155 </span>typeCheckMat
<span class="lineno">  156 </span>    :: forall shape channels depth
<span class="lineno">  157 </span>     . ( ToShapeDS    (Proxy shape)
<span class="lineno">  158 </span>       , ToChannelsDS (Proxy channels)
<span class="lineno">  159 </span>       , ToDepthDS    (Proxy depth)
<span class="lineno">  160 </span>       )
<span class="lineno">  161 </span>    =&gt; Mat shape channels depth -- ^ The matrix to be checked.
<span class="lineno">  162 </span>    -&gt; [CoerceMatError] -- ^ Error messages.
<span class="lineno">  163 </span><span class="decl"><span class="istickedoff">typeCheckMat mat =</span>
<span class="lineno">  164 </span><span class="spaces">       </span><span class="istickedoff">fromMaybe <span class="nottickedoff">[]</span> (checkShape &lt;$&gt; dsToMaybe dsExpectedShape)</span>
<span class="lineno">  165 </span><span class="spaces">    </span><span class="istickedoff">&lt;&gt; maybeToList (dsToMaybe dsExpectedNumChannels &gt;&gt;= checkNumChannels)</span>
<span class="lineno">  166 </span><span class="spaces">    </span><span class="istickedoff">&lt;&gt; maybeToList (dsToMaybe dsExpectedDepth &gt;&gt;= checkDepth)</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  168 </span><span class="spaces">    </span><span class="istickedoff">mi = matInfo mat</span>
<span class="lineno">  169 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  170 </span><span class="spaces">    </span><span class="istickedoff">dsExpectedShape :: DS [DS Int32]</span>
<span class="lineno">  171 </span><span class="spaces">    </span><span class="istickedoff">dsExpectedShape = toShapeDS <span class="nottickedoff">(Proxy :: Proxy shape)</span></span>
<span class="lineno">  172 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  173 </span><span class="spaces">    </span><span class="istickedoff">dsExpectedNumChannels :: DS Int32</span>
<span class="lineno">  174 </span><span class="spaces">    </span><span class="istickedoff">dsExpectedNumChannels = toChannelsDS <span class="nottickedoff">(Proxy :: Proxy channels)</span></span>
<span class="lineno">  175 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  176 </span><span class="spaces">    </span><span class="istickedoff">dsExpectedDepth :: DS Depth</span>
<span class="lineno">  177 </span><span class="spaces">    </span><span class="istickedoff">dsExpectedDepth = toDepthDS <span class="nottickedoff">(Proxy :: Proxy depth)</span></span>
<span class="lineno">  178 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  179 </span><span class="spaces">    </span><span class="istickedoff">checkShape :: [DS Int32] -&gt; [CoerceMatError]</span>
<span class="lineno">  180 </span><span class="spaces">    </span><span class="istickedoff">checkShape expectedShape = maybe checkSizes (:<span class="nottickedoff">[]</span>) dimCheck</span>
<span class="lineno">  181 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  182 </span><span class="spaces">        </span><span class="istickedoff">dimCheck :: Maybe CoerceMatError</span>
<span class="lineno">  183 </span><span class="spaces">        </span><span class="istickedoff">dimCheck | expectedDim == actualDim = Nothing</span>
<span class="lineno">  184 </span><span class="spaces">                 </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Just $ <span class="nottickedoff">ShapeError $ ExpectationError expectedDim actualDim</span></span>
<span class="lineno">  185 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  186 </span><span class="spaces">            </span><span class="istickedoff">expectedDim = length expectedShape</span>
<span class="lineno">  187 </span><span class="spaces">            </span><span class="istickedoff">actualDim = length (miShape mi)</span>
<span class="lineno">  188 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  189 </span><span class="spaces">        </span><span class="istickedoff">checkSizes :: [CoerceMatError]</span>
<span class="lineno">  190 </span><span class="spaces">        </span><span class="istickedoff">checkSizes = catMaybes $ zipWith3 checkSize [1..] expectedShape (miShape mi)</span>
<span class="lineno">  191 </span><span class="spaces">          </span><span class="istickedoff">where</span>
<span class="lineno">  192 </span><span class="spaces">            </span><span class="istickedoff">checkSize :: Int -&gt; DS Int32 -&gt; Int32 -&gt; Maybe CoerceMatError</span>
<span class="lineno">  193 </span><span class="spaces">            </span><span class="istickedoff">checkSize dimIx dsExpected actual = dsToMaybe dsExpected &gt;&gt;= \expected -&gt;</span>
<span class="lineno">  194 </span><span class="spaces">                </span><span class="istickedoff">if <span class="tickonlytrue">expected == actual</span></span>
<span class="lineno">  195 </span><span class="spaces">                </span><span class="istickedoff">then Nothing</span>
<span class="lineno">  196 </span><span class="spaces">                </span><span class="istickedoff">else <span class="nottickedoff">Just $ SizeError dimIx</span></span>
<span class="lineno">  197 </span><span class="spaces">                          </span><span class="istickedoff"><span class="nottickedoff">$ fromIntegral</span></span>
<span class="lineno">  198 </span><span class="spaces">                            </span><span class="istickedoff"><span class="nottickedoff">&lt;$&gt; ExpectationError expected actual</span></span>
<span class="lineno">  199 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">checkNumChannels :: Int32 -&gt; Maybe CoerceMatError</span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">checkNumChannels expectedNumChannels</span>
<span class="lineno">  202 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">miChannels mi == expectedNumChannels</span> = Nothing</span>
<span class="lineno">  203 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Just $ ChannelError</span></span>
<span class="lineno">  204 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">$ fromIntegral</span></span>
<span class="lineno">  205 </span><span class="spaces">                             </span><span class="istickedoff"><span class="nottickedoff">&lt;$&gt; ExpectationError expectedNumChannels (miChannels mi)</span></span>
<span class="lineno">  206 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  207 </span><span class="spaces">    </span><span class="istickedoff">checkDepth :: Depth -&gt; Maybe CoerceMatError</span>
<span class="lineno">  208 </span><span class="spaces">    </span><span class="istickedoff">checkDepth expectedDepth</span>
<span class="lineno">  209 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">miDepth mi == expectedDepth</span> = Nothing</span>
<span class="lineno">  210 </span><span class="spaces">        </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">Just $ DepthError</span></span>
<span class="lineno">  211 </span><span class="spaces">                           </span><span class="istickedoff"><span class="nottickedoff">$ ExpectationError expectedDepth (miDepth mi)</span></span></span>
<span class="lineno">  212 </span>
<span class="lineno">  213 </span>-- | Relaxes the type level constraints
<span class="lineno">  214 </span>--
<span class="lineno">  215 </span>-- Only identical or looser constraints are allowed. For tighter
<span class="lineno">  216 </span>-- constraints use 'coerceMat'.
<span class="lineno">  217 </span>--
<span class="lineno">  218 </span>-- This allows you to \'forget\' type level guarantees for zero
<span class="lineno">  219 </span>-- cost. Similar to 'unsafeCoerceMat', but totally safe.
<span class="lineno">  220 </span>--
<span class="lineno">  221 </span>-- [Identical] @a@ to @b@ with @a ~ b@
<span class="lineno">  222 </span>-- [Looser]  @(\''S' a)@ to @\''D'@ or @(\''S' a)@ to @(\''S' b)@ with @'MayRelax' a b@
<span class="lineno">  223 </span>-- [Tighter] @\''D'@ to @(\''S' a)@
<span class="lineno">  224 </span>relaxMat
<span class="lineno">  225 </span>    :: ( MayRelax shapeIn    shapeOut
<span class="lineno">  226 </span>       , MayRelax channelsIn channelsOut
<span class="lineno">  227 </span>       , MayRelax depthIn    depthOut
<span class="lineno">  228 </span>       )
<span class="lineno">  229 </span>    =&gt; Mat shapeIn  channelsIn  depthIn  -- ^ Original 'Mat'.
<span class="lineno">  230 </span>    -&gt; Mat shapeOut channelsOut depthOut -- ^ 'Mat' with relaxed constraints.
<span class="lineno">  231 </span><span class="decl"><span class="istickedoff">relaxMat = unsafeCoerce</span></span>
<span class="lineno">  232 </span>
<span class="lineno">  233 </span>coerceMat
<span class="lineno">  234 </span>    :: ( ToShapeDS    (Proxy shapeOut)
<span class="lineno">  235 </span>       , ToChannelsDS (Proxy channelsOut)
<span class="lineno">  236 </span>       , ToDepthDS    (Proxy depthOut)
<span class="lineno">  237 </span>       )
<span class="lineno">  238 </span>    =&gt; Mat shapeIn channelsIn depthIn -- ^
<span class="lineno">  239 </span>    -&gt; CvExcept (Mat shapeOut channelsOut depthOut)
<span class="lineno">  240 </span><span class="decl"><span class="istickedoff">coerceMat matIn | null errors = pure matOut</span>
<span class="lineno">  241 </span><span class="spaces">                </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span>   = throwE $ CoerceMatError errors</span>
<span class="lineno">  242 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  243 </span><span class="spaces">    </span><span class="istickedoff">matOut = unsafeCoerceMat matIn</span>
<span class="lineno">  244 </span><span class="spaces">    </span><span class="istickedoff">errors = typeCheckMat matOut</span></span>
<span class="lineno">  245 </span>
<span class="lineno">  246 </span>unsafeCoerceMat
<span class="lineno">  247 </span>    :: Mat shapeIn  channelsIn  depthIn
<span class="lineno">  248 </span>    -&gt; Mat shapeOut channelsOut depthOut
<span class="lineno">  249 </span><span class="decl"><span class="istickedoff">unsafeCoerceMat = unsafeCoerce</span></span>
<span class="lineno">  250 </span>
<span class="lineno">  251 </span>-- | Similar to 'withPtr' in that it keeps the 'ForeignPtr' alive
<span class="lineno">  252 </span>-- during the execution of the given action but it doesn't extract the 'Ptr'
<span class="lineno">  253 </span>-- from the 'ForeignPtr'.
<span class="lineno">  254 </span>keepMatAliveDuring :: Mat shape channels depth -&gt; IO a -&gt; IO a
<span class="lineno">  255 </span><span class="decl"><span class="istickedoff">keepMatAliveDuring mat m = do</span>
<span class="lineno">  256 </span><span class="spaces">    </span><span class="istickedoff">x &lt;- m</span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">touchForeignPtr $ unMat mat</span>
<span class="lineno">  258 </span><span class="spaces">    </span><span class="istickedoff">pure x</span></span>
<span class="lineno">  259 </span>
<span class="lineno">  260 </span>newEmptyMat :: IO (Mat ('S '[]) ('S 1) ('S Word8))
<span class="lineno">  261 </span><span class="decl"><span class="istickedoff">newEmptyMat = unsafeCoerceMat &lt;$&gt; fromPtr [CU.exp|Mat * { new Mat() }|]</span></span>
<span class="lineno">  262 </span>
<span class="lineno">  263 </span>-- TODO (RvD): what happens if we construct a mat with more than 4 channels?
<span class="lineno">  264 </span>-- A scalar is just 4 values. What would be the default value of the 5th channel?
<span class="lineno">  265 </span>newMat
<span class="lineno">  266 </span>    :: ( ToShape    shape
<span class="lineno">  267 </span>       , ToChannels channels
<span class="lineno">  268 </span>       , ToDepth    depth
<span class="lineno">  269 </span>       , ToScalar   scalar
<span class="lineno">  270 </span>       -- , MinLengthDS 2 shape
<span class="lineno">  271 </span>       -- , 1 .&lt;=? channels
<span class="lineno">  272 </span>       -- , channels .&lt;=? 512
<span class="lineno">  273 </span>       -- , 2 &lt;= Length shape
<span class="lineno">  274 </span>       -- , 1 &lt;= channels
<span class="lineno">  275 </span>       -- , channels &lt;= 512
<span class="lineno">  276 </span>       )
<span class="lineno">  277 </span>    =&gt; shape -- ^
<span class="lineno">  278 </span>    -&gt; channels
<span class="lineno">  279 </span>    -&gt; depth
<span class="lineno">  280 </span>    -&gt; scalar
<span class="lineno">  281 </span>    -&gt; CvExceptT IO (Mat (ShapeT shape) (ChannelsT channels) (DepthT depth))
<span class="lineno">  282 </span><span class="decl"><span class="istickedoff">newMat shape channels depth defValue = ExceptT $ do</span>
<span class="lineno">  283 </span><span class="spaces">    </span><span class="istickedoff">dst &lt;- newEmptyMat</span>
<span class="lineno">  284 </span><span class="spaces">    </span><span class="istickedoff">handleCvException (pure $ unsafeCoerceMat dst) $</span>
<span class="lineno">  285 </span><span class="spaces">      </span><span class="istickedoff">withVector shape' $ \shapePtr -&gt;</span>
<span class="lineno">  286 </span><span class="spaces">      </span><span class="istickedoff">withPtr (toScalar defValue) $ \scalarPtr -&gt;</span>
<span class="lineno">  287 </span><span class="spaces">      </span><span class="istickedoff">withPtr dst $ \dstPtr -&gt;</span>
<span class="lineno">  288 </span><span class="spaces">        </span><span class="istickedoff">[cvExcept|</span>
<span class="lineno">  289 </span><span class="spaces">          </span><span class="istickedoff">*$(Mat * dstPtr) =</span>
<span class="lineno">  290 </span><span class="spaces">            </span><span class="istickedoff">Mat( $(int32_t c'ndims)</span>
<span class="lineno">  291 </span><span class="spaces">               </span><span class="istickedoff">, $(int32_t * shapePtr)</span>
<span class="lineno">  292 </span><span class="spaces">               </span><span class="istickedoff">, $(int32_t c'type)</span>
<span class="lineno">  293 </span><span class="spaces">               </span><span class="istickedoff">, *$(Scalar * scalarPtr)</span>
<span class="lineno">  294 </span><span class="spaces">               </span><span class="istickedoff">);</span>
<span class="lineno">  295 </span><span class="spaces">        </span><span class="istickedoff">|]</span>
<span class="lineno">  296 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  297 </span><span class="spaces">    </span><span class="istickedoff">c'ndims = fromIntegral $ VG.length shape'</span>
<span class="lineno">  298 </span><span class="spaces">    </span><span class="istickedoff">c'type  = marshalFlags depth' channels'</span>
<span class="lineno">  299 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  300 </span><span class="spaces">    </span><span class="istickedoff">shape'    = toShape shape</span>
<span class="lineno">  301 </span><span class="spaces">    </span><span class="istickedoff">channels' = toChannels channels</span>
<span class="lineno">  302 </span><span class="spaces">    </span><span class="istickedoff">depth'    = toDepth depth</span></span>
<span class="lineno">  303 </span>
<span class="lineno">  304 </span>-- TODO (BvD): Move to some Utility module.
<span class="lineno">  305 </span>withVector
<span class="lineno">  306 </span>    :: (VG.Vector v a, Storable a)
<span class="lineno">  307 </span>    =&gt; v a -- ^
<span class="lineno">  308 </span>    -&gt; (Ptr a -&gt; IO b)
<span class="lineno">  309 </span>    -&gt; IO b
<span class="lineno">  310 </span><span class="decl"><span class="istickedoff">withVector v f =</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">allocaArray n $ \ptr -&gt;</span>
<span class="lineno">  312 </span><span class="spaces">      </span><span class="istickedoff">let go !ix</span>
<span class="lineno">  313 </span><span class="spaces">              </span><span class="istickedoff">| ix &lt; n = do</span>
<span class="lineno">  314 </span><span class="spaces">                  </span><span class="istickedoff">pokeElemOff ptr ix (VG.unsafeIndex v ix)</span>
<span class="lineno">  315 </span><span class="spaces">                  </span><span class="istickedoff">go (ix+1)</span>
<span class="lineno">  316 </span><span class="spaces">              </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = f ptr</span>
<span class="lineno">  317 </span><span class="spaces">      </span><span class="istickedoff">in go 0</span>
<span class="lineno">  318 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  319 </span><span class="spaces">    </span><span class="istickedoff">n = VG.length v</span></span>
<span class="lineno">  320 </span>
<span class="lineno">  321 </span>withMatData
<span class="lineno">  322 </span>    :: Mat shape channels depth -- ^
<span class="lineno">  323 </span>    -&gt; ([CSize] -&gt; Ptr Word8 -&gt; IO a)
<span class="lineno">  324 </span>    -&gt; IO a
<span class="lineno">  325 </span><span class="decl"><span class="istickedoff">withMatData mat f = withPtr mat $ \matPtr -&gt;</span>
<span class="lineno">  326 </span><span class="spaces">    </span><span class="istickedoff">alloca $ \(dimsPtr  :: Ptr Int32      ) -&gt;</span>
<span class="lineno">  327 </span><span class="spaces">    </span><span class="istickedoff">alloca $ \(stepPtr2 :: Ptr (Ptr CSize)) -&gt;</span>
<span class="lineno">  328 </span><span class="spaces">    </span><span class="istickedoff">alloca $ \(dataPtr2 :: Ptr (Ptr Word8)) -&gt; do</span>
<span class="lineno">  329 </span><span class="spaces">      </span><span class="istickedoff">[CU.block|void {</span>
<span class="lineno">  330 </span><span class="spaces">        </span><span class="istickedoff">const Mat * const matPtr = $(Mat * matPtr);</span>
<span class="lineno">  331 </span><span class="spaces">        </span><span class="istickedoff">*$(int32_t *   const dimsPtr ) = matPtr-&gt;dims;</span>
<span class="lineno">  332 </span><span class="spaces">        </span><span class="istickedoff">*$(size_t  * * const stepPtr2) = matPtr-&gt;step.p;</span>
<span class="lineno">  333 </span><span class="spaces">        </span><span class="istickedoff">*$(uint8_t * * const dataPtr2) = matPtr-&gt;data;</span>
<span class="lineno">  334 </span><span class="spaces">      </span><span class="istickedoff">}|]</span>
<span class="lineno">  335 </span><span class="spaces">      </span><span class="istickedoff">dims    &lt;- peek dimsPtr</span>
<span class="lineno">  336 </span><span class="spaces">      </span><span class="istickedoff">stepPtr &lt;- peek stepPtr2</span>
<span class="lineno">  337 </span><span class="spaces">      </span><span class="istickedoff">dataPtr &lt;- peek dataPtr2</span>
<span class="lineno">  338 </span><span class="spaces">      </span><span class="istickedoff">step    &lt;- peekArray (fromIntegral dims) stepPtr</span>
<span class="lineno">  339 </span><span class="spaces">      </span><span class="istickedoff">f step dataPtr</span></span>
<span class="lineno">  340 </span>
<span class="lineno">  341 </span>matElemAddress :: Ptr Word8 -&gt; [Int] -&gt; [Int] -&gt; Ptr a
<span class="lineno">  342 </span><span class="decl"><span class="istickedoff">matElemAddress dataPtr step pos = dataPtr `plusPtr` offset</span>
<span class="lineno">  343 </span><span class="spaces">    </span><span class="istickedoff">where</span>
<span class="lineno">  344 </span><span class="spaces">      </span><span class="istickedoff">offset = sum $ zipWith (*) step pos</span></span>
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>-- TODO (RvD): check for negative sizes
<span class="lineno">  347 </span>-- This crashes OpenCV
<span class="lineno">  348 </span>mkMat
<span class="lineno">  349 </span>    :: ( ToShape    shape
<span class="lineno">  350 </span>       , ToChannels channels
<span class="lineno">  351 </span>       , ToDepth    depth
<span class="lineno">  352 </span>       , ToScalar   scalar
<span class="lineno">  353 </span>       )
<span class="lineno">  354 </span>    =&gt; shape    -- ^
<span class="lineno">  355 </span>    -&gt; channels -- ^
<span class="lineno">  356 </span>    -&gt; depth    -- ^
<span class="lineno">  357 </span>    -&gt; scalar   -- ^
<span class="lineno">  358 </span>    -&gt; CvExcept (Mat (ShapeT shape) (ChannelsT channels) (DepthT depth))
<span class="lineno">  359 </span><span class="decl"><span class="istickedoff">mkMat shape channels depth defValue =</span>
<span class="lineno">  360 </span><span class="spaces">    </span><span class="istickedoff">unsafeCvExcept $ newMat <span class="nottickedoff">shape</span> <span class="nottickedoff">channels</span> <span class="nottickedoff">depth</span> defValue</span></span>
<span class="lineno">  361 </span>
<span class="lineno">  362 </span>cloneMat :: Mat shape channels depth
<span class="lineno">  363 </span>         -&gt; Mat shape channels depth
<span class="lineno">  364 </span><span class="decl"><span class="nottickedoff">cloneMat = unsafePerformIO . cloneMatIO</span></span>
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>cloneMatIO :: Mat shape channels depth
<span class="lineno">  367 </span>           -&gt; IO (Mat shape channels depth)
<span class="lineno">  368 </span><span class="decl"><span class="istickedoff">cloneMatIO mat =</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff">fmap unsafeCoerceMat $ fromPtr $ withPtr mat $ \matPtr -&gt;</span>
<span class="lineno">  370 </span><span class="spaces">      </span><span class="istickedoff">[C.exp|Mat * { new Mat($(Mat * matPtr)-&gt;clone()) }|]</span></span>
<span class="lineno">  371 </span>
<span class="lineno">  372 </span>--------------------------------------------------------------------------------
<span class="lineno">  373 </span>-- Mutable matrix
<span class="lineno">  374 </span>--------------------------------------------------------------------------------
<span class="lineno">  375 </span>
<span class="lineno">  376 </span>typeCheckMatM
<span class="lineno">  377 </span>    :: forall shape channels depth s
<span class="lineno">  378 </span>     . ( ToShapeDS    (Proxy shape)
<span class="lineno">  379 </span>       , ToChannelsDS (Proxy channels)
<span class="lineno">  380 </span>       , ToDepthDS    (Proxy depth)
<span class="lineno">  381 </span>       )
<span class="lineno">  382 </span>    =&gt; Mut (Mat shape channels depth) s -- ^ The matrix to be checked.
<span class="lineno">  383 </span>    -&gt; [CoerceMatError] -- ^ Error messages.
<span class="lineno">  384 </span><span class="decl"><span class="nottickedoff">typeCheckMatM = typeCheckMat . unMut</span></span>
<span class="lineno">  385 </span>
<span class="lineno">  386 </span>relaxMatM
<span class="lineno">  387 </span>    :: ( MayRelax shapeIn    shapeOut
<span class="lineno">  388 </span>       , MayRelax channelsIn channelsOut
<span class="lineno">  389 </span>       , MayRelax depthIn    depthOut
<span class="lineno">  390 </span>       )
<span class="lineno">  391 </span>    =&gt; Mut (Mat shapeIn  channelsIn  depthIn ) s -- ^ Original 'Mat'.
<span class="lineno">  392 </span>    -&gt; Mut (Mat shapeOut channelsOut depthOut) s -- ^ 'Mat' with relaxed constraints.
<span class="lineno">  393 </span><span class="decl"><span class="nottickedoff">relaxMatM = unsafeCoerce</span></span>
<span class="lineno">  394 </span>
<span class="lineno">  395 </span>coerceMatM
<span class="lineno">  396 </span>    :: ( ToShapeDS    (Proxy shapeOut)
<span class="lineno">  397 </span>       , ToChannelsDS (Proxy channelsOut)
<span class="lineno">  398 </span>       , ToDepthDS    (Proxy depthOut)
<span class="lineno">  399 </span>       )
<span class="lineno">  400 </span>    =&gt; Mut (Mat shapeIn channelsIn depthIn) s -- ^
<span class="lineno">  401 </span>    -&gt; CvExcept (Mut (Mat shapeOut channelsOut depthOut) s)
<span class="lineno">  402 </span><span class="decl"><span class="nottickedoff">coerceMatM = fmap Mut . coerceMat . unMut</span></span>
<span class="lineno">  403 </span>
<span class="lineno">  404 </span>unsafeCoerceMatM
<span class="lineno">  405 </span>    :: Mut (Mat shapeIn  channelsIn  depthIn ) s
<span class="lineno">  406 </span>    -&gt; Mut (Mat shapeOut channelsOut depthOut) s
<span class="lineno">  407 </span><span class="decl"><span class="nottickedoff">unsafeCoerceMatM = unsafeCoerce</span></span>
<span class="lineno">  408 </span>
<span class="lineno">  409 </span>-- TODO (RvD): check for negative sizes
<span class="lineno">  410 </span>-- This crashes OpenCV
<span class="lineno">  411 </span>mkMatM
<span class="lineno">  412 </span>    :: ( PrimMonad m
<span class="lineno">  413 </span>       , ToShape    shape
<span class="lineno">  414 </span>       , ToChannels channels
<span class="lineno">  415 </span>       , ToDepth    depth
<span class="lineno">  416 </span>       , ToScalar   scalar
<span class="lineno">  417 </span>       )
<span class="lineno">  418 </span>    =&gt; shape    -- ^
<span class="lineno">  419 </span>    -&gt; channels -- ^
<span class="lineno">  420 </span>    -&gt; depth    -- ^
<span class="lineno">  421 </span>    -&gt; scalar   -- ^
<span class="lineno">  422 </span>    -&gt; CvExceptT m (Mut (Mat (ShapeT shape) (ChannelsT channels) (DepthT depth)) (PrimState m))
<span class="lineno">  423 </span><span class="decl"><span class="istickedoff">mkMatM shape channels depth defValue = do</span>
<span class="lineno">  424 </span><span class="spaces">    </span><span class="istickedoff">mat &lt;- mapExceptT unsafePrimToPrim $ newMat shape <span class="nottickedoff">channels</span> <span class="nottickedoff">depth</span> defValue</span>
<span class="lineno">  425 </span><span class="spaces">    </span><span class="istickedoff">unsafeThaw mat</span></span>
<span class="lineno">  426 </span>
<span class="lineno">  427 </span>createMat
<span class="lineno">  428 </span>    :: (forall s. CvExceptT (ST s) (Mut (Mat shape channels depth) s)) -- ^
<span class="lineno">  429 </span>    -&gt; CvExcept (Mat shape channels depth)
<span class="lineno">  430 </span><span class="decl"><span class="istickedoff">createMat mk = runCvExceptST $ unsafeFreeze =&lt;&lt; mk</span></span>
<span class="lineno">  431 </span>
<span class="lineno">  432 </span>withMatM
<span class="lineno">  433 </span>    :: ( ToShape    shape
<span class="lineno">  434 </span>       , ToChannels channels
<span class="lineno">  435 </span>       , ToDepth    depth
<span class="lineno">  436 </span>       , ToScalar   scalar
<span class="lineno">  437 </span>       )
<span class="lineno">  438 </span>    =&gt; shape    -- ^
<span class="lineno">  439 </span>    -&gt; channels -- ^
<span class="lineno">  440 </span>    -&gt; depth    -- ^
<span class="lineno">  441 </span>    -&gt; scalar   -- ^
<span class="lineno">  442 </span>    -&gt; (  forall s
<span class="lineno">  443 </span>       .  Mut (Mat (ShapeT shape) (ChannelsT channels) (DepthT depth)) (PrimState (ST s))
<span class="lineno">  444 </span>       -&gt; CvExceptT (ST s) ()
<span class="lineno">  445 </span>       )
<span class="lineno">  446 </span>    -&gt; CvExcept (Mat (ShapeT shape) (ChannelsT channels) (DepthT depth))
<span class="lineno">  447 </span><span class="decl"><span class="istickedoff">withMatM shape channels depth defValue f = createMat $ do</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">matM &lt;- mkMatM shape <span class="nottickedoff">channels</span> <span class="nottickedoff">depth</span> defValue</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">f matM</span>
<span class="lineno">  450 </span><span class="spaces">    </span><span class="istickedoff">pure matM</span></span>
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>cloneMatM :: (PrimMonad m)
<span class="lineno">  453 </span>          =&gt; Mat shape channels depth
<span class="lineno">  454 </span>          -&gt; m (Mat shape channels depth)
<span class="lineno">  455 </span><span class="decl"><span class="istickedoff">cloneMatM = unsafePrimToPrim . cloneMatIO</span></span>
<span class="lineno">  456 </span>
<span class="lineno">  457 </span>
<span class="lineno">  458 </span>--------------------------------------------------------------------------------
<span class="lineno">  459 </span>-- Meta information
<span class="lineno">  460 </span>--------------------------------------------------------------------------------
<span class="lineno">  461 </span>
<span class="lineno">  462 </span>data MatInfo
<span class="lineno">  463 </span>   = MatInfo
<span class="lineno">  464 </span>     { <span class="istickedoff"><span class="decl"><span class="istickedoff">miShape</span></span></span>    :: ![Int32]
<span class="lineno">  465 </span>     , <span class="istickedoff"><span class="decl"><span class="istickedoff">miDepth</span></span></span>    :: !Depth
<span class="lineno">  466 </span>     , <span class="istickedoff"><span class="decl"><span class="istickedoff">miChannels</span></span></span> :: !Int32
<span class="lineno">  467 </span>     }
<span class="lineno">  468 </span>     deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>matInfo :: Mat shape channels depth -&gt; MatInfo
<span class="lineno">  471 </span><span class="decl"><span class="istickedoff">matInfo mat = unsafePerformIO $</span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="istickedoff">withPtr mat $ \matPtr -&gt;</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="istickedoff">alloca $ \(flagsPtr :: Ptr Int32) -&gt;</span>
<span class="lineno">  474 </span><span class="spaces">    </span><span class="istickedoff">alloca $ \(dimsPtr  :: Ptr Int32) -&gt;</span>
<span class="lineno">  475 </span><span class="spaces">    </span><span class="istickedoff">alloca $ \(sizePtr  :: Ptr (Ptr Int32)) -&gt; do</span>
<span class="lineno">  476 </span><span class="spaces">      </span><span class="istickedoff">[CU.block|void {</span>
<span class="lineno">  477 </span><span class="spaces">        </span><span class="istickedoff">const Mat * const matPtr = $(Mat * matPtr);</span>
<span class="lineno">  478 </span><span class="spaces">        </span><span class="istickedoff">*$(int32_t *   const flagsPtr) = matPtr-&gt;flags;</span>
<span class="lineno">  479 </span><span class="spaces">        </span><span class="istickedoff">*$(int32_t *   const dimsPtr ) = matPtr-&gt;dims;</span>
<span class="lineno">  480 </span><span class="spaces">        </span><span class="istickedoff">*$(int32_t * * const sizePtr ) = matPtr-&gt;size.p;</span>
<span class="lineno">  481 </span><span class="spaces">      </span><span class="istickedoff">}|]</span>
<span class="lineno">  482 </span><span class="spaces">      </span><span class="istickedoff">(depth, channels) &lt;- unmarshalFlags &lt;$&gt; peek flagsPtr</span>
<span class="lineno">  483 </span><span class="spaces">      </span><span class="istickedoff">dims &lt;- peek dimsPtr</span>
<span class="lineno">  484 </span><span class="spaces">      </span><span class="istickedoff">size &lt;- peek sizePtr</span>
<span class="lineno">  485 </span><span class="spaces">      </span><span class="istickedoff">shape &lt;- peekArray (fromIntegral dims) size</span>
<span class="lineno">  486 </span><span class="spaces">      </span><span class="istickedoff">pure MatInfo</span>
<span class="lineno">  487 </span><span class="spaces">           </span><span class="istickedoff">{ miShape    = shape</span>
<span class="lineno">  488 </span><span class="spaces">           </span><span class="istickedoff">, miDepth    = depth</span>
<span class="lineno">  489 </span><span class="spaces">           </span><span class="istickedoff">, miChannels = channels</span>
<span class="lineno">  490 </span><span class="spaces">           </span><span class="istickedoff">}</span></span>
<span class="lineno">  491 </span>
<span class="lineno">  492 </span>-- | All possible positions (indexes) for a given shape (list of
<span class="lineno">  493 </span>-- sizes per dimension).
<span class="lineno">  494 </span>dimPositions :: (Num a, Enum a) =&gt; [a] -&gt; [[a]]
<span class="lineno">  495 </span><span class="decl"><span class="istickedoff">dimPositions shape = sequence $ map (enumFromTo 0) $ map pred shape</span></span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>--------------------------------------------------------------------------------
<span class="lineno">  498 </span>
<span class="lineno">  499 </span>type family ShapeT (a :: ka) :: DS [DS Nat] where
<span class="lineno">  500 </span>    ShapeT [Int32]          = 'D
<span class="lineno">  501 </span>    ShapeT (V.Vector Int32) = 'D
<span class="lineno">  502 </span>    ShapeT (x ::: xs)       = 'S (DSNats (x ::: xs))
<span class="lineno">  503 </span>    ShapeT (xs :: [Nat])    = 'S (DSNats xs)
<span class="lineno">  504 </span>    ShapeT (Proxy a)        = ShapeT a
<span class="lineno">  505 </span>
<span class="lineno">  506 </span>type ChannelsT a = DSNat a
<span class="lineno">  507 </span>
<span class="lineno">  508 </span>--------------------------------------------------------------------------------
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>class ToShape a where
<span class="lineno">  511 </span>    toShape :: a -&gt; V.Vector Int32
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>-- | identity
<span class="lineno">  514 </span>instance ToShape (V.Vector Int32) where
<span class="lineno">  515 </span>    <span class="decl"><span class="istickedoff">toShape = id</span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>-- | direct conversion to 'V.Vector'
<span class="lineno">  518 </span>instance ToShape [Int32] where
<span class="lineno">  519 </span>    <span class="decl"><span class="nottickedoff">toShape = V.fromList</span></span>
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>-- | empty 'V.Vector'
<span class="lineno">  522 </span>instance ToShape (Proxy '[]) where
<span class="lineno">  523 </span>    <span class="decl"><span class="istickedoff">toShape _proxy = V.empty</span></span>
<span class="lineno">  524 </span>
<span class="lineno">  525 </span>-- | fold over the type level list
<span class="lineno">  526 </span>instance (ToInt32 (Proxy a), ToShape (Proxy as))
<span class="lineno">  527 </span>      =&gt; ToShape (Proxy (a ': as)) where
<span class="lineno">  528 </span>    <span class="decl"><span class="istickedoff">toShape _proxy =</span>
<span class="lineno">  529 </span><span class="spaces">        </span><span class="istickedoff">V.cons</span>
<span class="lineno">  530 </span><span class="spaces">          </span><span class="istickedoff">(toInt32 <span class="nottickedoff">(Proxy :: Proxy a)</span>)</span>
<span class="lineno">  531 </span><span class="spaces">          </span><span class="istickedoff">(toShape <span class="nottickedoff">(Proxy :: Proxy as)</span>)</span></span>
<span class="lineno">  532 </span>
<span class="lineno">  533 </span>-- | empty 'V.Vector'
<span class="lineno">  534 </span>instance ToShape Z where
<span class="lineno">  535 </span>    <span class="decl"><span class="istickedoff">toShape Z = V.empty</span></span>
<span class="lineno">  536 </span>
<span class="lineno">  537 </span>-- | fold over ':::'
<span class="lineno">  538 </span>instance (ToInt32 a, ToShape as) =&gt; ToShape (a ::: as) where
<span class="lineno">  539 </span>    <span class="decl"><span class="istickedoff">toShape (a ::: as) = V.cons (toInt32 a) (toShape as)</span></span>
<span class="lineno">  540 </span>
<span class="lineno">  541 </span>--------------------------------------------------------------------------------
<span class="lineno">  542 </span>
<span class="lineno">  543 </span>class ToShapeDS a where
<span class="lineno">  544 </span>    toShapeDS :: a -&gt; DS [DS Int32]
<span class="lineno">  545 </span>
<span class="lineno">  546 </span>instance ToShapeDS (proxy 'D) where
<span class="lineno">  547 </span>    <span class="decl"><span class="nottickedoff">toShapeDS _proxy = D</span></span>
<span class="lineno">  548 </span>
<span class="lineno">  549 </span>instance (ToNatListDS (Proxy as)) =&gt; ToShapeDS (Proxy ('S as)) where
<span class="lineno">  550 </span>    <span class="decl"><span class="istickedoff">toShapeDS _proxy = S $ toNatListDS <span class="nottickedoff">(Proxy :: Proxy as)</span></span></span>
<span class="lineno">  551 </span>
<span class="lineno">  552 </span>--------------------------------------------------------------------------------
<span class="lineno">  553 </span>
<span class="lineno">  554 </span>type ToChannels a = ToInt32 a
<span class="lineno">  555 </span>
<span class="lineno">  556 </span>toChannels :: (ToInt32 a) =&gt; a -&gt; Int32
<span class="lineno">  557 </span><span class="decl"><span class="istickedoff">toChannels = toInt32</span></span>
<span class="lineno">  558 </span>
<span class="lineno">  559 </span>type ToChannelsDS a = ToNatDS a
<span class="lineno">  560 </span>
<span class="lineno">  561 </span>toChannelsDS :: (ToChannelsDS a) =&gt; a -&gt; DS Int32
<span class="lineno">  562 </span><span class="decl"><span class="istickedoff">toChannelsDS = toNatDS</span></span>
<span class="lineno">  563 </span>
<span class="lineno">  564 </span>--------------------------------------------------------------------------------
<span class="lineno">  565 </span>
<span class="lineno">  566 </span><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">mkPlacementNewInstance ''Mat</span></span></span></span></span>

</pre>
</body>
</html>
